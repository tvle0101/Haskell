/*
Protocol: Anti-Quantum Cross-Server Authentication (AQCSA) Protocol for the Industrial Internet of Drones

Modeler: Tuan-Vinh Le
*/

theory AQCSA_Protocol
begin

builtins: symmetric-encryption, asymmetric-encryption, hashing, signing

// Suppose U is the Ui, S is the Se, W is the Sf, in the AQCSA

// Registering a public key of Se
rule Register_pkd:  
  [ Fr(~d) ]
  -->
  [ !Ltk($S, ~d), !Pk($S, pk(~d)) , Out(pk(~d)) ]

// Registering a public key of Sf
rule Register_pkv:
    [ Fr(~v) ]
  -->
    [ !Ltk($W, ~v), !Pk($W, pk(~v)) , Out(pk(~v)) ]

// User registration: suppose e are credentials, e:= <~f,~b>
rule setup:
	[ Fr(~k) , Fr(~e)]
	--[]->
	[ AgSt($U,<~k,~e>), AgSt($S,~k) ]

rule User_1: 	  
  [ AgSt($U,<~k,~e>) ]
 	--[ Send($U,~e) ]-> 
	[ User_1( ~e ) 
    , Out(senc(~e , ~k)) ]

rule Server_1:
	[ AgSt($S,~k), In(senc(~e , ~k))  ]
	--[ Receive($S,~e), Secret(~e) ]->
  [ Server_1( ~e ) ]

// Role W sends a message to S
rule W_1_send:
let m = <W, ~epsilon>
in
[ Fr(~epsilon)
, !Ltk(W, v)
, !Pk(S, d)
]
--[ Send(W, m)
]->
[ St_A_1(W, v, S, d, ~epsilon)
, Out(<m,sign(m,v)>)
]

// Role S receives the message
rule S_1_receive:
[ !Ltk(S, d)
, !Pk(W, pkW)
, In(<m,sig>)
]
--[ Recv(S, m)
, Eq(verify(sig,m,pkW),true)
, Authentic(W,m), Honest(S), Honest(W)
]->
[ St_B_1(S, d, pkW, W, m)
, S_1_receive(S, m)
]

restriction Equality:
"All x y #i. Eq(x,y) @i ==> x = y"

// Start a new thread executing the U, choosing a server S
rule User_2:
    [ Fr(~a)         // choose random number
    , !Pk($S, pkS)   // lookup public-key of S
    ]
  -->  
    [ User_2( $S, ~a)    // Store server and key for next step of thread
    , Out( aenc(~a, pkS) )  // Send the encrypted the key to the S
    ]

rule User_3:
    [ S_1_receive(S, epsilon)  // Retrieve server and 'epsilon' from previous step
    , User_2(S, a)   // Retrieve server and session key from previous step
    , User_1(e)
    , In( h(a, e) )       // Receive hashed key from network
    ]
  --[ SessKeyC( S, a ) ]-> // State that the key
    []                     // was setup with S and W; then the session key shared with another Uj
                           // is generated from 'e', 'a', and 'epsilon'

// The Uj also computes the session key shared with the Ui
// by the assistance of W and S in a similar way.

// A server thread answering in one-step to a session-key setup request from
// some U
rule Server_2:
    [ !Ltk($S, ~dS)                             // lookup the private-key
    , Server_1(e)
    , In( request )                               // receive a request
    ]
  --[ AnswerRequest($S, adec(request, ~dS)) ]-> // Explanation below
    [ Out( h(adec(request, ~dS), e) ) ]            // Return the hash of the
                                                  // decrypted request.

lemma ephemeral_secret: 
    "All e #i #j. Secret(e) @i & K(e) @j ==> F"
                                                
lemma functional: exists-trace
    "Ex U S e #i #j.
        Send(U , e) @i
        & Receive(S , e) @j "

lemma Session_key_secrecy:
  " /* It cannot be that 'a'  */
    not(
      Ex S a #i #j.
        /* U has set up a key with S */
        SessKeyC(S, a) @ #i
        /* and the adversary knows 'a' */
      & K(a) @ #j
        /* without having performed a long-term key reveal on S. */
    )
  "

lemma User_auth:
  " /* For all keys 'a' setup by clients with a S */
    ( All S a #i.  SessKeyC(S, a) @ #i
       ==>
         /* there is a server that answered the request */
       ( (Ex #a. AnswerRequest(S, a) @ a)
         /* or the adversary performed a long-term key reveal on S
            before the key was setup. */
       )
    )
  "

lemma User_auth_injective:
  " /* For all keys 'a' setup by clients with a server */
    ( All S a #i.  SessKeyC(S, a) @ #i
       ==>
         /* there is a server that answered the request */
       ( (Ex #a. AnswerRequest(S, a) @ a
           /* and there is no other client that had the same request */
           & (All #j. SessKeyC(S, a) @ #j ==> #i = #j)
       )
         /* or the adversary performed a long-term key reveal on S
            before the key was setup. */
       )
    )
  "

lemma Session_key_honest_setup:
  exists-trace
  " Ex S a #i.
        SessKeyC(S, a) @ #i
  "

lemma executable:
exists-trace
"Ex W S m #i #j. Send(W,m)@i & Recv(S,m) @j"

lemma message_authentication:
"All s m #i. Authentic(s,m) @i
==> (Ex #j. Send(s,m) @j & j<i)
"

end
